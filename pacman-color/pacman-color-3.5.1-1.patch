diff -Naur pacman-3.5.1/src/pacman/callback.c pacman-color-3.5.1/src/pacman/callback.c
--- pacman-3.5.1/src/pacman/callback.c	2011-03-16 16:41:32.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/callback.c	2011-03-23 18:37:08.000000000 +0100
@@ -218,16 +218,16 @@
 			printf(_("generating %s with %s... "), (char *)data1, (char *)data2);
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_DONE:
-			printf(_("success!\n"));
+			color_printf(COLOR_GREEN_ALL, _("success!\n"));
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_FAILED:
-			printf(_("failed.\n"));
+			color_printf(COLOR_RED_ALL, _("failed.\n"));
 			break;
 		case PM_TRANS_EVT_SCRIPTLET_INFO:
 			printf("%s", (char*)data1);
 			break;
 		case PM_TRANS_EVT_RETRIEVE_START:
-			printf(_(":: Retrieving packages from %s...\n"), (char*)data1);
+			color_printf(COLOR_DOUBLECOLON, _(":: Retrieving packages from %s...\n"), (char*)data1);
 			break;
 		case PM_TRANS_EVT_DISKSPACE_START:
 			if(config->noprogressbar) {
@@ -256,11 +256,11 @@
 {
 	switch(event) {
 		case PM_TRANS_CONV_INSTALL_IGNOREPKG:
-			*response = yesno(_(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
 							  alpm_pkg_get_name(data1));
 			break;
 		case PM_TRANS_CONV_REPLACE_PKG:
-			*response = yesno(_(":: Replace %s with %s/%s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: Replace %s with %s/%s?"),
 					alpm_pkg_get_name(data1),
 					(char *)data3,
 					alpm_pkg_get_name(data2));
@@ -269,12 +269,12 @@
 			/* data parameters: target package, local package, conflict (strings) */
 			/* print conflict only if it contains new information */
 			if(strcmp(data1, data3) == 0 || strcmp(data2, data3) == 0) {
-				*response = noyes(_(":: %s and %s are in conflict. Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict. Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data2);
 			} else {
-				*response = noyes(_(":: %s and %s are in conflict (%s). Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s). Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data3,
@@ -291,13 +291,13 @@
 							(char *)alpm_pkg_get_name(i->data));
 					count++;
 				}
-				printf(_n(
+				color_printf(COLOR_DOUBLECOLON, _n(
 							":: The following package cannot be upgraded due to unresolvable dependencies:\n",
 							":: The following packages cannot be upgraded due to unresolvable dependencies:\n",
 							count));
-				list_display("     ", namelist);
+				list_display(NULL, "     ", namelist);
 				printf("\n");
-				*response = noyes(_n(
+				*response = noyes(NULL, _n(
 							"Do you want to skip the above package for this upgrade?",
 							"Do you want to skip the above packages for this upgrade?",
 							count));
@@ -309,7 +309,7 @@
 				alpm_list_t *providers = (alpm_list_t *)data1;
 				int count = alpm_list_count(providers);
 				char *depstring = alpm_dep_compute_string((pmdepend_t *)data2);
-				printf(_(":: There are %d providers available for %s:\n"), count,
+				color_printf(COLOR_DOUBLECOLON, _(":: There are %d providers available for %s:\n"), count,
 						depstring);
 				free(depstring);
 				select_display(providers);
@@ -318,7 +318,7 @@
 			break;
 		case PM_TRANS_CONV_LOCAL_NEWER:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s-%s: local version is newer. Upgrade anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s-%s: local version is newer. Upgrade anyway?"),
 						alpm_pkg_get_name(data1),
 						alpm_pkg_get_version(data1));
 			} else {
@@ -326,7 +326,7 @@
 			}
 			break;
 		case PM_TRANS_CONV_CORRUPTED_PKG:
-			*response = yesno(_(":: File %s is corrupted. Do you want to delete it?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: File %s is corrupted. Do you want to delete it?"),
 					(char *)data1);
 			break;
 	}
@@ -448,8 +448,9 @@
 
 	}
 
-	printf("(%*ld/%*ld) %ls%-*s", digits, (unsigned long)current,
-			digits, (unsigned long)howmany, wcstr, padwid, "");
+	color_printf(COLOR_BLUE_ALL, "(%*ld/%*ld)", digits, (unsigned long)current,
+				 digits, (unsigned long)howmany);
+	printf(" %ls%-*s", wcstr, padwid, "");
 
 	free(wcstr);
 
diff -Naur pacman-3.5.1/src/pacman/package.c pacman-color-3.5.1/src/pacman/package.c
--- pacman-3.5.1/src/pacman/package.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/package.c	2011-03-23 18:37:43.000000000 +0100
@@ -92,47 +92,47 @@
 	}
 
 	/* actual output */
-	string_display(_("Name           :"), alpm_pkg_get_name(pkg));
-	string_display(_("Version        :"), alpm_pkg_get_version(pkg));
-	string_display(_("URL            :"), alpm_pkg_get_url(pkg));
-	list_display(_("Licenses       :"), alpm_pkg_get_licenses(pkg));
-	list_display(_("Groups         :"), alpm_pkg_get_groups(pkg));
-	list_display(_("Provides       :"), alpm_pkg_get_provides(pkg));
-	list_display(_("Depends On     :"), depstrings);
-	list_display_linebreak(_("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Name           :"), COLOR_WHITE_ALL, alpm_pkg_get_name(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Version        :"), COLOR_GREEN_ALL, alpm_pkg_get_version(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("URL            :"), COLOR_CYAN_ALL, alpm_pkg_get_url(pkg));
+	list_display(COLOR_WHITE_ALL, _("Licenses       :"), alpm_pkg_get_licenses(pkg));
+	list_display(COLOR_WHITE_ALL, _("Groups         :"), alpm_pkg_get_groups(pkg));
+	list_display(COLOR_WHITE_ALL, _("Provides       :"), alpm_pkg_get_provides(pkg));
+	list_display(COLOR_WHITE_ALL, _("Depends On     :"), depstrings);
+	list_display_linebreak(COLOR_WHITE_ALL, _("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
 	if(level > 0 || level < -1) {
-		list_display(_("Required By    :"), requiredby);
+		list_display(COLOR_WHITE_ALL, _("Required By    :"), requiredby);
 	}
-	list_display(_("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
-	list_display(_("Replaces       :"), alpm_pkg_get_replaces(pkg));
+	list_display(COLOR_WHITE_ALL, _("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
+	list_display(COLOR_WHITE_ALL, _("Replaces       :"), alpm_pkg_get_replaces(pkg));
 	if(level < 0) {
-		printf(_("Download Size  : %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Download Size  : %6.2f K\n"),
 			(double)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 	if(level == 0) {
-		printf(_("Compressed Size: %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Compressed Size: %6.2f K\n"),
 			(double)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 
-	printf(_("Installed Size : %6.2f K\n"),
+	color_printf(COLOR_WHITE_COLON, _("Installed Size : %6.2f K\n"),
 			(double)alpm_pkg_get_isize(pkg) / 1024.0);
-	string_display(_("Packager       :"), alpm_pkg_get_packager(pkg));
-	string_display(_("Architecture   :"), alpm_pkg_get_arch(pkg));
-	string_display(_("Build Date     :"), bdatestr);
+	string_display(COLOR_WHITE_ALL, _("Packager       :"), alpm_pkg_get_packager(pkg));
+	string_display(COLOR_WHITE_ALL, _("Architecture   :"), alpm_pkg_get_arch(pkg));
+	string_display(COLOR_WHITE_ALL, _("Build Date     :"), bdatestr);
 	if(level > 0) {
-		string_display(_("Install Date   :"), idatestr);
-		string_display(_("Install Reason :"), reason);
+		string_display(COLOR_WHITE_ALL, _("Install Date   :"), idatestr);
+		string_display(COLOR_WHITE_ALL, _("Install Reason :"), reason);
 	}
 	if(level >= 0) {
-		string_display(_("Install Script :"),
+		string_display(COLOR_WHITE_ALL, _("Install Script :"),
 				alpm_pkg_has_scriptlet(pkg) ?  _("Yes") : _("No"));
 	}
 
 	/* MD5 Sum for sync package */
 	if(level < 0) {
-		string_display(_("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
 	}
-	string_display(_("Description    :"), alpm_pkg_get_desc(pkg));
+	string_display(COLOR_WHITE_ALL, _("Description    :"), alpm_pkg_get_desc(pkg));
 
 	/* Print additional package info if info flag passed more than once */
 	if(level > 1) {
@@ -153,7 +153,7 @@
 	if(pkg == NULL) {
 		return;
 	}
-	string_display(_("Repository     :"), treename);
+	color_string_display(COLOR_WHITE_ALL, _("Repository     :"), COLOR_MAGENTA_ALL, treename);
 	/* invert the level since we are a sync package */
 	dump_pkg_full(pkg, -level);
 }
@@ -204,7 +204,7 @@
 {
 	alpm_list_t *i;
 	const char *root = alpm_option_get_root();
-	printf(_("Backup Files:\n"));
+	color_printf(COLOR_WHITE_ALL, _("Backup Files:\n"));
 	if(alpm_pkg_get_backup(pkg)) {
 		/* package has backup files, so print them */
 		for(i = alpm_pkg_get_backup(pkg); i; i = alpm_list_next(i)) {
@@ -241,7 +241,8 @@
 	for(i = pkgfiles; i; i = alpm_list_next(i)) {
 		filestr = alpm_list_getdata(i);
 		if(!quiet){
-			fprintf(stdout, "%s %s%s\n", pkgname, root, filestr);
+			color_fprintf(stdout, COLOR_WHITE_ALL, "%s", pkgname);
+			fprintf(stdout, " %s%s\n", root, filestr);
 		} else {
 			fprintf(stdout, "%s%s\n", root, filestr);
 		}
diff -Naur pacman-3.5.1/src/pacman/pacman.c pacman-color-3.5.1/src/pacman/pacman.c
--- pacman-3.5.1/src/pacman/pacman.c	2011-03-21 13:40:13.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/pacman.c	2011-03-23 18:38:55.000000000 +0100
@@ -217,11 +217,22 @@
  */
 static void version(void)
 {
-	printf("\n");
-	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
-	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2011 Pacman Development Team\n");
-	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
-	printf(" '--'\n");
+	color_printf(COLOR_YELLOW_ALL, " .--. ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, " .---. ");
+	printf("  Pacman-color v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	color_printf(COLOR_YELLOW_ALL, "/ _.-'");
+	color_printf(COLOR_WHITE_ALL, " .-.  .-");
+	color_printf(COLOR_RED_ALL, "|O O  |");
+	printf("  Copyright (C) 2006-2011 Pacman Development Team\n");
+	color_printf(COLOR_YELLOW_ALL, "\\  '-.");
+	color_printf(COLOR_WHITE_ALL, " '-'  '-");
+	color_printf(COLOR_RED_ALL, "|~~~  |");
+	printf("  Copyright (C) 2002-2006 Judd Vinet\n");
+	color_printf(COLOR_YELLOW_ALL, " '--' ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, "|.-.-.|");
+	printf("  Colored by vogo <vogo(at)seznam(dot)cz>\n");
 	printf(_("                       This program may be freely redistributed under\n"
 	         "                       the terms of the GNU General Public License.\n"));
 	printf("\n");
@@ -1321,6 +1332,7 @@
 
 	/* init config data */
 	config = config_new();
+	parsecolorconfig();
 
 	/* disable progressbar if the output is redirected */
 	if(!isatty(1)) {
@@ -1429,17 +1441,17 @@
 
 	if(config->verbose > 0) {
 		alpm_list_t *i;
-		printf("Root      : %s\n", alpm_option_get_root());
-		printf("Conf File : %s\n", config->configfile);
-		printf("DB Path   : %s\n", alpm_option_get_dbpath());
-		printf("Cache Dirs: ");
+		string_display(COLOR_WHITE_ALL, "Root      :", alpm_option_get_root());
+		string_display(COLOR_WHITE_ALL, "Conf File :", config->configfile);
+		string_display(COLOR_WHITE_ALL, "DB Path   :", alpm_option_get_dbpath());
+		color_printf(COLOR_WHITE_ALL, "Cache Dirs: ");
 		for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
 			printf("%s  ", (char*)alpm_list_getdata(i));
 		}
 		printf("\n");
-		printf("Lock File : %s\n", alpm_option_get_lockfile());
-		printf("Log File  : %s\n", alpm_option_get_logfile());
-		list_display("Targets   :", pm_targets);
+		string_display(COLOR_WHITE_ALL, "Lock File :", alpm_option_get_lockfile());
+		string_display(COLOR_WHITE_ALL, "Log File  :", alpm_option_get_logfile());
+		list_display(COLOR_WHITE_ALL, "Targets   :", pm_targets);
 	}
 
 	/* Log commandline */
diff -Naur pacman-3.5.1/src/pacman/query.c pacman-color-3.5.1/src/pacman/query.c
--- pacman-3.5.1/src/pacman/query.c	2011-03-16 16:41:32.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/query.c	2011-03-23 18:39:23.000000000 +0100
@@ -240,7 +240,9 @@
 		pmpkg_t *pkg = alpm_list_getdata(i);
 
 		if (!config->quiet) {
-			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_MAGENTA_ALL, "local/");
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s", alpm_pkg_get_name(pkg));
 		}
@@ -257,16 +259,11 @@
 		if (!config->quiet) {
 			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 				alpm_list_t *k;
-				printf(" (");
+				color_printf(COLOR_BLUE_ALL, " (");
 				for(k = grp; k; k = alpm_list_next(k)) {
 					const char *group = alpm_list_getdata(k);
-					printf("%s", group);
-					if(alpm_list_next(k)) {
-						/* only print a spacer if there are more groups */
-						printf(" ");
-					}
+					color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 				}
-				printf(")");
 			}
 
 			/* we need a newline and initial indent first */
@@ -300,7 +297,8 @@
 			packages = alpm_grp_get_pkgs(grp);
 
 			for(p = packages; p; p = alpm_list_next(p)) {
-				printf("%s %s\n", grpname, alpm_pkg_get_name(alpm_list_getdata(p)));
+				color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+				color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 			}
 		}
 	} else {
@@ -312,8 +310,8 @@
 				const alpm_list_t *p, *packages = alpm_grp_get_pkgs(grp);
 				for(p = packages; p; p = alpm_list_next(p)) {
 					if(!config->quiet) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(p)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					} else {
 						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					}
@@ -461,7 +459,8 @@
 	if(!config->op_q_info && !config->op_q_list
 			&& !config->op_q_changelog && !config->op_q_check) {
 		if (!config->quiet) {
-			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s\n", alpm_pkg_get_name(pkg));
 		}
diff -Naur pacman-3.5.1/src/pacman/remove.c pacman-color-3.5.1/src/pacman/remove.c
--- pacman-3.5.1/src/pacman/remove.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/remove.c	2011-03-23 18:39:39.000000000 +0100
@@ -106,7 +106,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -114,7 +114,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -137,7 +137,7 @@
 			holdpkg = 1;
 		}
 	}
-	if(holdpkg && (noyes(_("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
+	if(holdpkg && (noyes(NULL, _("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
 		retval = 1;
 		goto cleanup;
 	}
@@ -157,7 +157,7 @@
 	/* print targets and ask user confirmation */
 	display_targets(pkglist, 0);
 	printf("\n");
-	if(yesno(_("Do you want to remove these packages?")) == 0) {
+	if(yesno(NULL, _("Do you want to remove these packages?")) == 0) {
 		retval = 1;
 		goto cleanup;
 	}
diff -Naur pacman-3.5.1/src/pacman/sync.c pacman-color-3.5.1/src/pacman/sync.c
--- pacman-3.5.1/src/pacman/sync.c	2011-03-21 13:43:55.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/sync.c	2011-03-23 18:41:51.000000000 +0100
@@ -102,7 +102,7 @@
 		/* We have a database that doesn't match any syncdb.
 		 * Ask the user if he wants to remove it. */
 		if(!found) {
-			if(!yesno(_("Do you want to remove %s?"), path)) {
+			if(!yesno(NULL, _("Do you want to remove %s?"), path)) {
 				continue;
 			}
 
@@ -124,8 +124,8 @@
 	int ret = 0;
 
 	dbpath = alpm_option_get_dbpath();
-	printf(_("Database directory: %s\n"), dbpath);
-	if(!yesno(_("Do you want to remove unused repositories?"))) {
+	color_printf(COLOR_WHITE_COLON, _("Database directory: %s\n"), dbpath);
+	if(!yesno(NULL, _("Do you want to remove unused repositories?"))) {
 		return(0);
 	}
 	/* The sync dbs were previously put in dbpath/ but are now in dbpath/sync/.
@@ -148,7 +148,7 @@
 	int ret = 0;
 
 	for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
-		printf(_("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
 	}
 
 	if(!config->cleanmethod) {
@@ -157,19 +157,19 @@
 	}
 
 	if(level == 1) {
-		printf(_("Packages to keep:\n"));
+		color_printf(COLOR_WHITE_COLON, _("Packages to keep:\n"));
 		if(config->cleanmethod & PM_CLEAN_KEEPINST) {
 			printf(_("  All locally installed packages\n"));
 		}
 		if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
 			printf(_("  All current sync database packages\n"));
 		}
-		if(!yesno(_("Do you want to remove all other packages from cache?"))) {
+		if(!yesno(NULL, _("Do you want to remove all other packages from cache?"))) {
 			return(0);
 		}
 		printf(_("removing old packages from cache...\n"));
 	} else {
-		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+		if(!noyes(NULL, _("Do you want to remove ALL files from cache?"))) {
 			return(0);
 		}
 		printf(_("removing all files from cache...\n"));
@@ -212,7 +212,7 @@
 			 * files here that aren't valid packages. we also don't need a full
 			 * load of the package, just the metadata. */
 			if(alpm_pkg_load(path, 0, &localpkg) != 0 || localpkg == NULL) {
-				if(yesno(_("File %s does not seem to be a valid package, remove it?"), path)) {
+				if(yesno(NULL, _("File %s does not seem to be a valid package, remove it?"), path)) {
 					if(localpkg) {
 						alpm_pkg_free(localpkg);
 					}
@@ -306,9 +306,9 @@
 	if(lpkg) {
 		const char *lpkgver = alpm_pkg_get_version(lpkg);
 		if(strcmp(lpkgver,pkgver) == 0) {
-			printf(" [%s]", _("installed"));
+			color_printf(COLOR_CYAN_ALL, " [%s]", _("installed"));
 		} else {
-			printf(" [%s: %s]", _("installed"), lpkgver);
+			color_printf(COLOR_CYAN_ALL, " [%s: %s]", _("installed"), lpkgver);
 		}
 	}
 }
@@ -341,8 +341,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s/", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s", alpm_pkg_get_name(pkg));
 			}
@@ -358,16 +359,11 @@
 			if (!config->quiet) {
 				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 					alpm_list_t *k;
-					printf(" (");
+					color_printf(COLOR_BLUE_ALL, " (");
 					for(k = grp; k; k = alpm_list_next(k)) {
 						const char *group = alpm_list_getdata(k);
-						printf("%s", group);
-						if(alpm_list_next(k)) {
-							/* only print a spacer if there are more groups */
-							printf(" ");
-						}
+						color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 					}
-					printf(")");
 				}
 
 				print_installed(db_local, pkg);
@@ -402,8 +398,8 @@
 					/* get names of packages in group */
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
 						if(!config->quiet) {
-							printf("%s %s\n", grpname,
-									alpm_pkg_get_name(alpm_list_getdata(k)));
+							color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+							color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						} else {
 							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						}
@@ -421,8 +417,8 @@
 
 				if(level > 1) {
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(k)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 					}
 				} else {
 					/* print grp names only, no package names */
@@ -559,8 +555,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-						alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s ", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 				print_installed(db_local, pkg);
 				printf("\n");
 			} else {
@@ -639,7 +636,7 @@
 
 
 	if(config->print == 0) {
-		printf(_(":: There are %d members in group %s:\n"), count,
+		color_printf(COLOR_DOUBLECOLON, _(":: There are %d members in group %s:\n"), count,
 				group);
 		select_display(pkgs);
 		char *array = malloc(count);
@@ -746,7 +743,7 @@
 	}
 
 	if(config->op_s_upgrade) {
-		printf(_(":: Starting full system upgrade...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Starting full system upgrade...\n"));
 		alpm_logaction("starting full system upgrade\n");
 		if(alpm_sync_sysupgrade(config->op_s_upgrade >= 2) == -1) {
 			pm_fprintf(stderr, PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
@@ -764,7 +761,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -772,7 +769,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -785,9 +782,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(strcmp(package1, reason) == 0 || strcmp(package2, reason) == 0) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -817,9 +814,9 @@
 
 	int confirm;
 	if(config->op_s_downloadonly) {
-		confirm = yesno(_("Proceed with download?"));
+		confirm = yesno(NULL, _("Proceed with download?"));
 	} else {
-		confirm = yesno(_("Proceed with installation?"));
+		confirm = yesno(NULL, _("Proceed with installation?"));
 	}
 	if(!confirm) {
 		goto cleanup;
@@ -841,7 +838,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
@@ -859,7 +856,7 @@
 				break;
 		}
 		/* TODO: stderr? */
-		printf(_("Errors occurred, no packages were upgraded.\n"));
+		color_printf(COLOR_RED_ALL, _("Errors occurred, no packages were upgraded.\n"));
 		retval = 1;
 		goto cleanup;
 	}
@@ -908,7 +905,7 @@
 
 	if(config->op_s_sync) {
 		/* grab a fresh package list */
-		printf(_(":: Synchronizing package databases...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Synchronizing package databases...\n"));
 		alpm_logaction("synchronizing package lists\n");
 		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
 			return(1);
@@ -957,9 +954,9 @@
 			alpm_list_t *tmp = NULL;
 			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
 				alpm_list_free(tmp);
-				printf(_(":: The following packages should be upgraded first :\n"));
-				list_display("   ", packages);
-				if(yesno(_(":: Do you want to cancel the current operation\n"
+				color_printf(COLOR_DOUBLECOLON, _(":: The following packages should be upgraded first :\n"));
+				list_display(NULL, "   ", packages);
+				if(yesno(COLOR_DOUBLECOLON2, _(":: Do you want to cancel the current operation\n"
 								":: and upgrade these packages now?"))) {
 					FREELIST(targs);
 					targs = packages;
diff -Naur pacman-3.5.1/src/pacman/upgrade.c pacman-color-3.5.1/src/pacman/upgrade.c
--- pacman-3.5.1/src/pacman/upgrade.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/upgrade.c	2011-03-23 18:42:15.000000000 +0100
@@ -99,7 +99,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -111,7 +111,7 @@
 					/* TODO indicate if the error was a virtual package or not:
 					 *		:: %s: requires %s, provided by %s
 					 */
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -124,9 +124,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(strcmp(package1, reason) == 0 || strcmp(package2, reason) == 0) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -156,7 +156,7 @@
 	display_targets(alpm_trans_get_remove(), 0);
 	display_targets(alpm_trans_get_add(), 1);
 	printf("\n");
-	int confirm = yesno(_("Proceed with installation?"));
+	int confirm = yesno(NULL, _("Proceed with installation?"));
 	if(!confirm) {
 		trans_release();
 		return(retval);
@@ -178,7 +178,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
diff -Naur pacman-3.5.1/src/pacman/util.c pacman-color-3.5.1/src/pacman/util.c
--- pacman-3.5.1/src/pacman/util.c	2011-03-16 16:41:32.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/util.c	2011-03-23 18:44:09.000000000 +0100
@@ -46,6 +46,20 @@
 #include "conf.h"
 #include "callback.h"
 
+#define COLOR_LEN 8
+
+typedef struct __colortab_t {
+	char red[COLOR_LEN + 1];
+	char green[COLOR_LEN + 1];
+	char yellow[COLOR_LEN + 1];
+	char blue[COLOR_LEN + 1];
+	char magenta[COLOR_LEN + 1];
+	char cyan[COLOR_LEN + 1];
+	char white[COLOR_LEN + 1];
+	char none[COLOR_LEN + 1];
+} colortab_t;
+
+static colortab_t colortab;
 
 int trans_init(pmtransflag_t flags)
 {
@@ -423,12 +437,12 @@
 	return(len);
 }
 
-void string_display(const char *title, const char *string)
+void string_display(const colordata_t *colors_title, const char *title, const char *string)
 {
 	int len = 0;
 
 	if(title) {
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 	if(string == NULL || string[0] == '\0') {
 		printf(_("None"));
@@ -440,14 +454,14 @@
 	printf("\n");
 }
 
-void list_display(const char *title, const alpm_list_t *list)
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int cols, len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -476,14 +490,14 @@
 	}
 }
 
-void list_display_linebreak(const char *title, const alpm_list_t *list)
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -544,21 +558,21 @@
 
 	if(install) {
 		pm_asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_YELLOW_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Download Size:    %.2f MB\n"), mbdlsize);
+		color_printf(COLOR_WHITE_COLON, _("Total Download Size:    %.2f MB\n"), mbdlsize);
 		if(!(config->flags & PM_TRANS_FLAG_DOWNLOADONLY)) {
-			printf(_("Total Installed Size:   %.2f MB\n"), mbisize);
+			color_printf(COLOR_WHITE_COLON, _("Total Installed Size:   %.2f MB\n"), mbisize);
 		}
 	} else {
 		pm_asprintf(&str, _("Remove (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_RED_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Removed Size:   %.2f MB\n"), mbisize);
+		color_printf(COLOR_WHITE_COLON, _("Total Removed Size:   %.2f MB\n"), mbisize);
 	}
 
 	FREELIST(targets);
@@ -667,7 +681,7 @@
 	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
 	if(optdeps) {
 		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 	alpm_list_free(optdeps);
 }
@@ -677,7 +691,7 @@
 	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
 	if(optdeps) {
 		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 }
 
@@ -685,9 +699,9 @@
 {
 	const char *prefix= "  ";
 
-	printf(":: ");
-	printf(_("Repository %s\n"), dbname);
-	list_display(prefix, list);
+	color_printf(COLOR_BLUE_ALL, ":: ");
+	color_printf(COLOR_WHITE_ALL, _("Repository %s\n"), dbname);
+	list_display(NULL, prefix, list);
 }
 
 void select_display(const alpm_list_t *pkglist)
@@ -866,7 +880,7 @@
 
 
 /* presents a prompt and gets a Y/N answer */
-static int question(short preset, char *fmt, va_list args)
+static int question(const colordata_t *colors, short preset, char *fmt, va_list args)
 {
 	char response[32];
 	FILE *stream;
@@ -878,7 +892,7 @@
 		stream = stderr;
 	}
 
-	vfprintf(stream, fmt, args);
+	color_vfprintf(stream, colors, fmt, args);
 
 	if(preset) {
 		fprintf(stream, " %s ", _("[Y/n]"));
@@ -906,25 +920,25 @@
 	return(0);
 }
 
-int yesno(char *fmt, ...)
+int yesno(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(1, fmt, args);
+	ret = question(colors, 1, fmt, args);
 	va_end(args);
 
 	return(ret);
 }
 
-int noyes(char *fmt, ...)
+int noyes(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(0, fmt, args);
+	ret = question(colors, 0, fmt, args);
 	va_end(args);
 
 	return(ret);
@@ -986,22 +1000,40 @@
 	ret = vasprintf(&msg, format, args);
 
 	/* print a prefix to the message */
-	switch(level) {
-		case PM_LOG_ERROR:
-			pm_asprintf(string, _("error: %s"), msg);
-			break;
-		case PM_LOG_WARNING:
-			pm_asprintf(string, _("warning: %s"), msg);
-			break;
-		case PM_LOG_DEBUG:
-			pm_asprintf(string, "debug: %s", msg);
-			break;
-		case PM_LOG_FUNCTION:
-			pm_asprintf(string, "function: %s", msg);
-			break;
-		default:
-			pm_asprintf(string, "%s", msg);
-			break;
+	if(isatty(fileno(stdout))) {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, "%s%s%s%s", colortab.red, _("error: "), colortab.none, msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, "%s%s%s%s", colortab.yellow, _("warning: "), colortab.none, msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
+	} else {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, _("error: %s"), msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, _("warning: %s"), msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
 	}
 	free(msg);
 
@@ -1036,10 +1068,10 @@
 	/* print a prefix to the message */
 	switch(level) {
 		case PM_LOG_ERROR:
-			fprintf(stream, _("error: "));
+			color_fprintf(stream, COLOR_RED_ALL, _("error: "));
 			break;
 		case PM_LOG_WARNING:
-			fprintf(stream, _("warning: "));
+			color_fprintf(stream, COLOR_YELLOW_ALL, _("warning: "));
 			break;
 		case PM_LOG_DEBUG:
 			fprintf(stream, "debug: ");
@@ -1078,4 +1110,310 @@
 }
 #endif
 
+/* pacman-color */
+
+int _set_color_sequence(const char* name, char* dest)
+{
+	int ret = 0;
+
+	if(strcmp(name, "black") == 0) {
+		strncpy(dest, "\033[0;30m", COLOR_LEN);
+	} else if(strcmp(name, "red") == 0) {
+		strncpy(dest, "\033[0;31m", COLOR_LEN);
+	} else if(strcmp(name, "green") == 0) {
+		strncpy(dest, "\033[0;32m", COLOR_LEN);
+	} else if(strcmp(name, "yellow") == 0) {
+		strncpy(dest, "\033[0;33m", COLOR_LEN);
+	} else if(strcmp(name, "blue") == 0) {
+		strncpy(dest, "\033[0;34m", COLOR_LEN);
+	} else if(strcmp(name, "magenta") == 0) {
+		strncpy(dest, "\033[0;35m", COLOR_LEN);
+	} else if(strcmp(name, "cyan") == 0) {
+		strncpy(dest, "\033[0;36m", COLOR_LEN);
+	} else if(strcmp(name, "white") == 0) {
+		strncpy(dest, "\033[0;37m", COLOR_LEN);
+	} else if(strcmp(name, "gray") == 0) {
+		strncpy(dest, "\033[1;30m", COLOR_LEN);
+	} else if(strcmp(name, "intensive red") == 0) {
+		strncpy(dest, "\033[1;31m", COLOR_LEN);
+	} else if(strcmp(name, "intensive green") == 0) {
+		strncpy(dest, "\033[1;32m", COLOR_LEN);
+	} else if(strcmp(name, "intensive yellow") == 0) {
+		strncpy(dest, "\033[1;33m", COLOR_LEN);
+	} else if(strcmp(name, "intensive blue") == 0) {
+		strncpy(dest, "\033[1;34m", COLOR_LEN);
+	} else if(strcmp(name, "intensive magenta") == 0) {
+		strncpy(dest, "\033[1;35m", COLOR_LEN);
+	} else if(strcmp(name, "intensive cyan") == 0) {
+		strncpy(dest, "\033[1;36m", COLOR_LEN);
+	} else if(strcmp(name, "intensive white") == 0) {
+		strncpy(dest, "\033[1;37m", COLOR_LEN);
+	} else if(strcmp(name, "intensive foreground") == 0) {
+		strncpy(dest, "\033[m\033[1m", COLOR_LEN);
+	} else if(strcmp(name, "none") == 0) {
+		strncpy(dest, "\033[m", COLOR_LEN);
+	} else {
+		ret = 1;
+	}
+	dest[COLOR_LEN] = '\0';
+	return(ret);
+}
+
+void _insert_color(FILE* stream, color_t color)
+{
+	switch(color) {
+		case COLOR_RED:
+			fprintf(stream, colortab.red);
+			break;
+		case COLOR_GREEN:
+			fprintf(stream, colortab.green);
+			break;
+		case COLOR_YELLOW:
+			fprintf(stream, colortab.yellow);
+			break;
+		case COLOR_BLUE:
+			fprintf(stream, colortab.blue);
+			break;
+		case COLOR_MAGENTA:
+			fprintf(stream, colortab.magenta);
+			break;
+		case COLOR_CYAN:
+			fprintf(stream, colortab.cyan);
+			break;
+		case COLOR_WHITE:
+			fprintf(stream, colortab.white);
+			break;
+		case COLOR_NONE:
+			fprintf(stream, colortab.none);
+			break;
+		default:;
+	}
+}
+
+int _parsecolorconfig(colortab_t* colortab, char* file)
+{
+	_set_color_sequence("intensive red", colortab->red);
+	_set_color_sequence("intensive green", colortab->green);
+	_set_color_sequence("intensive yellow", colortab->yellow);
+	_set_color_sequence("intensive blue", colortab->blue);
+	_set_color_sequence("intensive magenta", colortab->magenta);
+	_set_color_sequence("intensive cyan", colortab->cyan);
+	_set_color_sequence("intensive foreground", colortab->white);
+	_set_color_sequence("none", colortab->none);
+
+	FILE* fp = NULL;
+	int linenum = 0;
+	char line[PATH_MAX+1];
+	char* ptr;
+
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(PM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return 1;
+	}
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		char* key = line;
+		ptr = line;
+		strsep(&ptr, "=");
+		strtrim(key);
+		strtrim(ptr);
+
+		if(key == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			return 1;
+		}
+		if(strcmp(key, "Red") == 0) {
+			if(_set_color_sequence(ptr, colortab->red)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Green") == 0) {
+			if(_set_color_sequence(ptr, colortab->green)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Yellow") == 0) {
+			if(_set_color_sequence(ptr, colortab->yellow)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Blue") == 0) {
+			if(_set_color_sequence(ptr, colortab->blue)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Magenta") == 0) {
+			if(_set_color_sequence(ptr, colortab->magenta)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Cyan") == 0) {
+			if(_set_color_sequence(ptr, colortab->cyan)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "White") == 0) {
+			if(_set_color_sequence(ptr, colortab->white)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' not recognized.\n"),
+					file, linenum, key);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+int parsecolorconfig()
+{
+	return(_parsecolorconfig(&colortab, "/etc/pacman.d/color.conf"));
+}
+
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args)
+{
+	int ret = 0;
+
+	if(isatty(fileno(stream)) && colors) {
+		char* msg = NULL;
+		ret = vasprintf(&msg, format, args);
+		if(msg == NULL) {
+			return(ret);
+		}
+
+		const colordata_t* colorpos = colors;
+		color_t colorlast = COLOR_NONE;
+		int len = strlen(msg) + 1;
+		wchar_t* wcstr = calloc(len, sizeof(wchar_t));
+		len = mbstowcs(wcstr, msg, len);
+		free(msg);
+		const wchar_t *strpos = wcstr;
+		
+		while(*strpos) {
+			if(colorpos->color != COLOR_END &&
+				((colorpos->separator == SEP_ANY) ||
+				 (colorpos->separator == SEP_LINE && *strpos == L'\n') ||
+				 (colorpos->separator == SEP_COLON && (*strpos == L':' || *strpos == L'：')))) {
+				_insert_color(stream, colorpos->color);
+				colorlast = colorpos->color;
+				colorpos++;
+			}
+			fprintf(stream, "%lc", (wint_t)*strpos);
+			strpos++;
+		}
+		free(wcstr);
+
+		if(colorlast != COLOR_NONE) {
+			_insert_color(stream, COLOR_NONE);
+		}
+	} else {
+		ret = vfprintf(stream, format, args);
+	}
+	return(ret);
+}
+
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stream, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+int color_printf(const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stdout, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string)
+{
+	if(title) {
+		color_printf(colors_title, "%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		color_printf(colors_string, "%s", string);
+	}
+	printf("\n");
+}
+
+const colordata_t COLOR_WHITE_ALL[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_GREEN_ALL[] = {
+	{ SEP_ANY, COLOR_GREEN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_RED_ALL[] = {
+	{ SEP_ANY, COLOR_RED },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_BLUE_ALL[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_YELLOW_ALL[] = {
+	{ SEP_ANY, COLOR_YELLOW },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_MAGENTA_ALL[] = {
+	{ SEP_ANY, COLOR_MAGENTA },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_CYAN_ALL[] = {
+	{ SEP_ANY, COLOR_CYAN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON2[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_WHITE_COLON[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_COLON, COLOR_SAME },
+	{ SEP_ANY, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
 /* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.1/src/pacman/util.h pacman-color-3.5.1/src/pacman/util.h
--- pacman-3.5.1/src/pacman/util.h	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.1/src/pacman/util.h	2011-03-23 19:01:23.000000000 +0100
@@ -39,6 +39,48 @@
 /* update speed for the fill_progress based functions */
 #define UPDATE_SPEED_SEC 0.2f
 
+/* pacman-color */
+typedef enum _separator_t {
+	SEP_ANY = 0,
+	SEP_LINE,
+	SEP_COLON,
+} separator_t;
+
+typedef enum _color_t {
+	COLOR_END = 0,
+	COLOR_SAME,
+	COLOR_RED,
+	COLOR_GREEN,
+	COLOR_YELLOW,
+	COLOR_BLUE,
+	COLOR_MAGENTA,
+	COLOR_CYAN,
+	COLOR_WHITE,
+	COLOR_NONE,
+} color_t;
+
+typedef struct _colordata_t {
+	separator_t separator;
+	color_t color;
+} colordata_t;
+
+extern const colordata_t COLOR_WHITE_ALL[];
+extern const colordata_t COLOR_GREEN_ALL[];
+extern const colordata_t COLOR_RED_ALL[];
+extern const colordata_t COLOR_BLUE_ALL[];
+extern const colordata_t COLOR_YELLOW_ALL[];
+extern const colordata_t COLOR_MAGENTA_ALL[];
+extern const colordata_t COLOR_CYAN_ALL[];
+extern const colordata_t COLOR_DOUBLECOLON[];
+extern const colordata_t COLOR_DOUBLECOLON2[];
+extern const colordata_t COLOR_WHITE_COLON[];
+
+int parsecolorconfig();
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...) __attribute__((format(printf,3,4)));
+int color_printf(const colordata_t* colors, const char* format, ...) __attribute__((format(printf,2,3)));
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args) __attribute__((format(printf,3,0)));
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string);
+
 int trans_init(pmtransflag_t flags);
 int trans_release(void);
 int needs_root(void);
@@ -51,9 +93,9 @@
 char *strtrim(char *str);
 char *strreplace(const char *str, const char *needle, const char *replace);
 alpm_list_t *strsplit(const char *str, const char splitchar);
-void string_display(const char *title, const char *string);
-void list_display(const char *title, const alpm_list_t *list);
-void list_display_linebreak(const char *title, const alpm_list_t *list);
+void string_display(const colordata_t *colors_title, const char *title, const char *string);
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
 void display_targets(const alpm_list_t *pkgs, int install);
 int str_cmp(const void *s1, const void *s2);
 void display_new_optdepends(pmpkg_t *oldpkg, pmpkg_t *newpkg);
@@ -62,8 +104,8 @@
 void select_display(const alpm_list_t *pkglist);
 int select_question(int count);
 int multiselect_question(char *array, int count);
-int yesno(char *fmt, ...);
-int noyes(char *fmt, ...);
+int yesno(const colordata_t *colors, char *fmt, ...);
+int noyes(const colordata_t *colors, char *fmt, ...);
 int pm_printf(pmloglevel_t level, const char *format, ...) __attribute__((format(printf,2,3)));
 int pm_fprintf(FILE *stream, pmloglevel_t level, const char *format, ...) __attribute__((format(printf,3,4)));
 int pm_asprintf(char **string, const char *format, ...);
